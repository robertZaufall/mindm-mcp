Directory structure:
└── mindm-mcp/
    ├── LICENSE
    ├── pyproject.toml
    ├── update_version.py
    ├── examples/
    │   └── usage_example.py
    └── mindm_mcp/
        ├── __init__.py
        └── server.py

================================================
File: LICENSE
================================================
MIT License

Copyright (c) [2025] [Robert Zaufall]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: pyproject.toml
================================================
[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[project]
name = "mindm_mcp"
version = "0.0.1.13"
authors = [
  { name="Robert Zaufall" },
]
description = "Model Context Protocol (MCP) server for the mindm library, enabling AI assistants like Claude to interact with MindManager."
readme = "README.md"
requires-python = ">=3.8"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: MIT License",
    "Operating System :: Microsoft :: Windows",
    "Operating System :: MacOS :: MacOS X",
]

dependencies = [
  "mindm>=0.0.3.8",
  "uvicorn>=0.22.0",
  "aiohttp>=3.8.4",
  "pydantic>=1.10.7",
  "websockets>=10.4",
]

[project.optional-dependencies]
dev = [
  "pytest>=7.0",
  "pytest-asyncio>=0.20.0",
  "black",
  "flake8",
]

[project.urls]
"Homepage" = "https://github.com/robertZaufall/mindm_mcp"
"Bug Tracker" = "https://github.com/robertZaufall/mindm_mcp/issues"

[project.scripts]
mindm-mcp-server = "mindm_mcp.server:main"

[tool.setuptools]
packages = ["mindm_mcp"]



================================================
File: update_version.py
================================================
#!/usr/bin/env python3
import re

# Read pyproject.toml
with open("pyproject.toml", "r") as f:
    content = f.read()

# Find version and update build number
version_pattern = r'version = "([\d]+)\.([\d]+)\.([\d]+)\.([\d]+)"'
version_match = re.search(version_pattern, content)

if version_match:
    major, minor, patch, build = version_match.groups()
    new_build = str(int(build) + 1)
    new_version = f"{major}.{minor}.{patch}.{new_build}"
    new_content = re.sub(version_pattern, f'version = "{new_version}"', content)
    
    # Write updated content back
    with open("pyproject.toml", "w") as f:
        f.write(new_content)
    
    print(f"Updated version to {new_version}")
else:
    print("Version pattern not found in pyproject.toml")


================================================
File: examples/usage_example.py
================================================
#!/usr/bin/env python3
"""
Example usage of the MCP for mindm library.
Make sure MindManager is open with a document before running this script.
"""

import json
import subprocess
import sys
import os

def call_mcp(function_name, args=None):
    """
    Call the MCP handler with the given function name and arguments.
    
    Args:
        function_name (str): Name of the MCP function to call
        args (dict, optional): Arguments to pass to the function
        
    Returns:
        dict: The response from the MCP handler
    """
    if args is None:
        args = {}
        
    request = {
        "function": function_name,
        "args": args
    }
    
    # Convert request to JSON string
    request_json = json.dumps(request)
    
    # Call the MCP handler script
    server_path = os.path.join(os.path.dirname(__file__), "..", "mindm_mcp", "server.py")
    result = subprocess.run(
        [sys.executable, server_path, request_json],
        capture_output=True,
        text=True
    )
    
    # Parse and return the response
    try:
        return json.loads(result.stdout)
    except json.JSONDecodeError:
        return {
            "status": "error",
            "message": f"Failed to parse response: {result.stdout}",
            "stderr": result.stderr
        }

def main():
    """Example workflow using the MCP for mindm."""
    print("Getting mindmap from MindManager...")
    result = call_mcp("get_mindmap", {"mode": "full"})
    
    if result["status"] == "error":
        print(f"Error: {result['message']}")
        return
    
    print("\nCurrent mindmap information:")
    print(f"Central topic: {result['mindmap']['central_topic']}")
    print(f"Total topics: {result['mindmap']['topic_count']}")
    print(f"Maximum level: {result['mindmap']['max_level']}")
    
    if result['mindmap']['selected_topics']:
        print("\nSelected topics:")
        for topic in result['mindmap']['selected_topics']:
            print(f"- {topic}")
    
    # Ask user if they want to create a new mindmap
    answer = input("\nDo you want to create a new mindmap from this structure? (y/n): ")
    if answer.lower() == 'y':
        print("\nCreating new mindmap...")
        create_result = call_mcp("create_mindmap", {"verbose": True})
        
        if create_result["status"] == "error":
            print(f"Error: {create_result['message']}")
        else:
            print(f"Success: {create_result['message']}")
            print(f"Created {create_result['topics_created']} topics")
    
    print("\nDone.")

if __name__ == "__main__":
    main()



================================================
File: mindm_mcp/__init__.py
================================================
# Version information
try:
    from importlib.metadata import version as _version
    __version__ = _version("mindm")
except ImportError:
    __version__ = "unknown"



================================================
File: mindm_mcp/server.py
================================================
#!/usr/bin/env python3
"""
Minimal MCP implementation for mindm library.
This script provides direct access to mindm functions from Claude Desktop.
"""

import sys
import json
import traceback
from typing import Dict, Any, Callable, Optional, List, Union

# Import the mindm library
import mindmap.mindmap as mm

class MCPHandler:
    """
    Model Context Protocol handler for mindm library.
    Provides a simple interface to call mindm functions from Claude Desktop.
    """
    
    def __init__(self):
        """Initialize the MCP handler."""
        self.document = None
        self.functions = {
            "get_mindmap": self.get_mindmap,
            "create_mindmap": self.create_mindmap,
            "list_functions": self.list_functions,
        }
    
    def list_functions(self, args: Dict[str, Any] = None) -> Dict[str, Any]:
        """List all available functions."""
        return {
            "status": "success",
            "functions": list(self.functions.keys())
        }
    
    def get_mindmap(self, args: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Load a mindmap from the currently open MindManager document.
        
        Args:
            args (Dict[str, Any], optional): Optional arguments.
                mode: 'full', 'content', or 'text' (default: 'full')
        
        Returns:
            Dict[str, Any]: Status and mindmap information.
        """
        try:
            # Create a document if we don't have one
            if self.document is None:
                self.document = mm.MindmapDocument()
            
            # Extract mode parameter if provided
            mode = 'full'
            if args and 'mode' in args:
                mode = args['mode']
            
            # Get the mindmap
            result = self.document.get_mindmap(mode=mode)
            
            if result:
                # Extract basic information (not the full object which could be huge)
                central_topic_text = self.document.mindmap.text
                topic_count = self._count_topics(self.document.mindmap)
                selected_count = len(self.document.selected_topic_texts)
                
                # Get grounding information
                top_most_topic, subtopics = self.document.get_grounding_information()
                
                return {
                    "status": "success",
                    "mindmap": {
                        "central_topic": central_topic_text,
                        "topic_count": topic_count,
                        "max_level": self.document.max_topic_level,
                        "selected_topics": self.document.selected_topic_texts,
                        "top_most_topic": top_most_topic,
                        "subtopics": subtopics
                    }
                }
            else:
                return {
                    "status": "error",
                    "message": "Failed to get mindmap. No document is open in MindManager."
                }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "traceback": traceback.format_exc()
            }
    
    def create_mindmap(self, args: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Create a new mindmap document based on the loaded mindmap structure.
        
        Args:
            args (Dict[str, Any], optional): Optional arguments.
                verbose: Whether to enable verbose output (default: False)
        
        Returns:
            Dict[str, Any]: Status and creation result.
        """
        try:
            # Check if we have a document and mindmap loaded
            if self.document is None or self.document.mindmap is None:
                return {
                    "status": "error",
                    "message": "No mindmap loaded. Call get_mindmap first."
                }
            
            # Extract verbose parameter if provided
            verbose = False
            if args and 'verbose' in args:
                verbose = args['verbose']
            
            # Create the mindmap
            self.document.create_mindmap(verbose=verbose)
            
            return {
                "status": "success",
                "message": "Mindmap created successfully",
                "topics_created": self._count_topics(self.document.mindmap)
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e),
                "traceback": traceback.format_exc()
            }
    
    def _count_topics(self, topic, count=0, visited=None):
        """
        Recursively count topics in a mindmap.
        
        Args:
            topic: The topic to start counting from
            count: Current count
            visited: Set of visited topics to prevent infinite recursion
            
        Returns:
            int: Total count of topics
        """
        if visited is None:
            visited = set()
            
        if topic.guid in visited:
            return count
            
        visited.add(topic.guid)
        count += 1
        
        for subtopic in topic.subtopics:
            count = self._count_topics(subtopic, count, visited)
            
        return count
    
    def handle_request(self, request_str: str) -> str:
        """
        Parse and handle MCP requests.
        
        Args:
            request_str (str): JSON string with function name and arguments
            
        Returns:
            str: JSON response string
        """
        try:
            request = json.loads(request_str)
            function_name = request.get("function", "")
            args = request.get("args", {})
            
            if function_name in self.functions:
                result = self.functions[function_name](args)
                return json.dumps(result)
            else:
                return json.dumps({
                    "status": "error",
                    "message": f"Unknown function: {function_name}",
                    "available_functions": list(self.functions.keys())
                })
        except Exception as e:
            return json.dumps({
                "status": "error",
                "message": f"Error handling request: {str(e)}",
                "traceback": traceback.format_exc()
            })

def main():
    """Main entry point for the MCP handler."""
    handler = MCPHandler()
    
    # If arguments are provided, process as a single request
    if len(sys.argv) > 1:
        request = sys.argv[1]
        response = handler.handle_request(request)
        print(response)
        return
    
    # Otherwise, enter interactive mode
    while True:
        try:
            line = input("> ")
            if line.lower() in ["exit", "quit"]:
                break
                
            response = handler.handle_request(line)
            print(response)
        except KeyboardInterrupt:
            break
        except Exception as e:
            print(f"Error: {e}")

if __name__ == "__main__":
    main()


