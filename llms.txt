Directory structure:
└── mindm-mcp/
    ├── README.md
    ├── LICENSE
    ├── pyproject.toml
    ├── update_version.py
    ├── examples/
    │   └── client.py
    └── mindm_mcp/
        ├── __init__.py
        └── server.py

================================================
File: README.md
================================================
# MindManager MCP Server

A Model Context Protocol (MCP) server implementation for the `mindm` library, providing a standardized interface to interact with MindManager on Windows and macOS.

## Overview

This server allows you to programmatically interact with MindManager through the Model Context Protocol (MCP), a standardized way to provide context and tools to LLMs. It leverages the `mindm` library to manipulate MindManager documents, topics, relationships, and other mindmap elements.

## Features

- Initialize MindManager connection with platform-specific settings
- Retrieve mindmap structure and central topics
- Create new mindmaps from serialized data
- Add, modify, and manipulate topics and subtopics
- Add relationships between topics
- Add tags to topics
- Export mindmaps to Mermaid and Markdown formats
- Get information about MindManager installation and library folders
- Set document background images
- Get current selection from MindManager

## Requirements

- Python 3.9 or higher
- `mcp` package (Model Context Protocol SDK)
- `mindm` library (included in this project)
- MindManager (supported versions: 23-) installed on Windows or macOS

## Installation

```bash
# Install required packages
pip install mcp

# Clone the repository (if you're using it from a repository)
git clone https://github.com/robertZaufall/mindm-mcp.git
cd mindm-mcp
```

## Usage

### Starting the server

```bash
# Using the CLI
python server.py --host localhost --port 8000

# Alternative: Install with the MCP CLI
mcp install server.py
```

### Client example

```python
import asyncio
from client import MindManagerClient

async def main():
    # Create client instance
    client = MindManagerClient(server_url="http://localhost:8000")
    
    try:
        # Connect to server
        await client.connect()
        
        # Initialize connection to MindManager
        result = await client.initialize()
        if result["status"] == "success":
            print("Connected to MindManager successfully!")
            
        # Get the central topic
        central = await client.get_central_topic()
        if central["status"] == "success":
            topic = central.get("topic", {})
            print(f"Central topic: {topic.get('text', '')}")
            
        # Add a subtopic
        if topic and "guid" in topic:
            subtopic = await client.add_subtopic(topic["guid"], "New subtopic from MCP")
            print(f"Added subtopic with GUID: {subtopic.get('guid', '')}")
    
    finally:
        # Disconnect when done
        await client.disconnect()

if __name__ == "__main__":
    asyncio.run(main())
```

## MCP Tools

The server exposes the following tools through the Model Context Protocol:

- `initialize`: Initialize connection to MindManager
- `get_version`: Get MindManager version
- `get_mindmap`: Get the current mindmap structure
- `get_central_topic`: Get the central topic of the current mindmap
- `get_selection`: Get currently selected topics
- `create_mindmap`: Create a new mindmap from provided structure
- `add_subtopic`: Add a subtopic to an existing topic
- `set_topic_text`: Update a topic's text content
- `add_relationship`: Add a relationship between topics
- `add_tag`: Add a tag to a topic
- `get_library_folder`: Get MindManager library folder path
- `set_background_image`: Set document background image
- `export_to_mermaid`: Export mindmap to Mermaid format
- `export_to_markdown`: Export mindmap to Markdown format

## MCP Resources

The server exposes the following resources:

- `mindmanager://info`: Information about the MindManager application

## Platform Support

- **Windows**: Full support for topics, notes, icons, images, tags, links, relationships, and RTF formatting
- **macOS**: Support for topics, notes, and relationships (limited support compared to Windows)

## Integration with Claude and other LLMs

This MCP server can be installed in Claude Desktop or other MCP-compatible applications, allowing LLMs to:

1. Access mindmap content
2. Manipulate mindmaps programmatically
3. Create new mindmaps based on LLM-generated content

## Troubleshooting

- Ensure MindManager is running before starting the server
- For macOS, verify that the `appscript` package is installed
- Check that the correct MindManager version (23-26) is installed
- Verify server URL and port settings in the client

## Acknowledgements

This project is built upon the `mindm` library developed by Robert Zaufall, providing Python interfaces to MindManager on Windows and macOS platforms. It uses the Model Context Protocol (MCP) SDK developed by Anthropic.

## License

MIT License - See LICENSE file for details



================================================
File: LICENSE
================================================
MIT License

Copyright (c) [2025] [Robert Zaufall]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
File: pyproject.toml
================================================
[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[project]
name = "mindm_mcp"
version = "0.0.1.3"
authors = [
  { name="Robert Zaufall" },
]
description = "Model Context Protocol (MCP) server for the mindm library, enabling AI assistants like Claude to interact with MindManager."
readme = "README.md"
requires-python = ">=3.8"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: MIT License",
    "Operating System :: Microsoft :: Windows",
    "Operating System :: MacOS :: MacOS X",
]

dependencies = [
  "mindm>=0.0.4.1",
  "uvicorn>=0.22.0",
  "aiohttp>=3.8.4",
  "pydantic>=1.10.7",
  "websockets>=10.4",
]

[project.optional-dependencies]
dev = [
  "pytest>=7.0",
  "pytest-asyncio>=0.20.0",
  "black",
  "flake8",
]

[project.urls]
"Homepage" = "https://github.com/robertZaufall/mindm_mcp"
"Bug Tracker" = "https://github.com/robertZaufall/mindm_mcp/issues"

[project.scripts]
mindm-mcp = "mindm_mcp.server:main"

[tool.setuptools]
packages = ["mindm_mcp"]



================================================
File: update_version.py
================================================
#!/usr/bin/env python3
import re

# Read pyproject.toml
with open("pyproject.toml", "r") as f:
    content = f.read()

# Find version and update build number
version_pattern = r'version = "([\d]+)\.([\d]+)\.([\d]+)\.([\d]+)"'
version_match = re.search(version_pattern, content)

if version_match:
    major, minor, patch, build = version_match.groups()
    new_build = str(int(build) + 1)
    new_version = f"{major}.{minor}.{patch}.{new_build}"
    new_content = re.sub(version_pattern, f'version = "{new_version}"', content)
    
    # Write updated content back
    with open("pyproject.toml", "w") as f:
        f.write(new_content)
    
    print(f"Updated version to {new_version}")
else:
    print("Version pattern not found in pyproject.toml")


================================================
File: examples/client.py
================================================
#!/usr/bin/env python3
"""
client.py - Example client for interacting with the mindm MCP server

This module demonstrates how to use the MCP client to interact with
the mindm server to manipulate MindManager maps programmatically.
"""

import json
import sys
import logging
import asyncio
from typing import Dict, Any, Optional, List, Union

try:
    from mcp.client import Client, ClientConfig
except ImportError:
    print("Error: Model Context Protocol SDK is required")
    print("Install with: pip install mcp")
    sys.exit(1)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("mindm-mcp-client")

class MindManagerClient:
    """
    Client for interacting with the MindManager MCP server
    """
    
    def __init__(self, server_url: str = "http://localhost:8000"):
        """
        Initialize the MindManager client
        
        Args:
            server_url (str): URL of the MCP server
        """
        config = ClientConfig(server_url=server_url)
        self.client = Client(config)
        
    async def connect(self):
        """
        Connect to the MCP server
        """
        await self.client.connect()
        logger.info(f"Connected to MindManager MCP server at {self.client.config.server_url}")
    
    async def disconnect(self):
        """
        Disconnect from the MCP server
        """
        await self.client.disconnect()
        logger.info("Disconnected from MindManager MCP server")
    
    async def initialize(self, charttype: str = "auto", macos_access: str = "appscript") -> Dict[str, Any]:
        """
        Initialize the MindManager interface
        
        Args:
            charttype (str): Chart type (auto, orgchart, radial)
            macos_access (str): macOS access method (appscript, applescript)
            
        Returns:
            Dict[str, Any]: Initialization status
        """
        return await self.client.call_tool("initialize", {
            "charttype": charttype,
            "macos_access": macos_access
        })
    
    async def get_version(self) -> Dict[str, Any]:
        """
        Get the MindManager version
        
        Returns:
            Dict[str, Any]: Version information
        """
        return await self.client.call_tool("get_version")
    
    async def get_mindmap(self, mode: str = "full") -> Dict[str, Any]:
        """
        Get the current mindmap structure
        
        Args:
            mode (str): Attribute gathering mode (full, content, text)
            
        Returns:
            Dict[str, Any]: Mindmap data
        """
        return await self.client.call_tool("get_mindmap", {
            "mode": mode
        })
    
    async def get_central_topic(self) -> Dict[str, Any]:
        """
        Get the central topic of the mindmap
        
        Returns:
            Dict[str, Any]: Central topic data
        """
        return await self.client.call_tool("get_central_topic")
    
    async def get_selection(self) -> Dict[str, Any]:
        """
        Get the currently selected topics
        
        Returns:
            Dict[str, Any]: Selected topics data
        """
        return await self.client.call_tool("get_selection")
    
    async def create_mindmap(self, mindmap_data: Dict[str, Any], charttype: str = "auto") -> Dict[str, Any]:
        """
        Create a new mindmap from the provided structure
        
        Args:
            mindmap_data (Dict[str, Any]): Serialized mindmap structure
            charttype (str): Chart type to use
            
        Returns:
            Dict[str, Any]: Creation status
        """
        return await self.client.call_tool("create_mindmap", {
            "mindmap_data": mindmap_data,
            "charttype": charttype
        })
    
    async def add_subtopic(self, parent_guid: str, text: str = "New Topic") -> Dict[str, Any]:
        """
        Add a subtopic to an existing topic
        
        Args:
            parent_guid (str): GUID of the parent topic
            text (str): Text content for the new subtopic
            
        Returns:
            Dict[str, Any]: Operation status with new subtopic GUID
        """
        return await self.client.call_tool("add_subtopic", {
            "parent_guid": parent_guid,
            "text": text
        })
    
    async def set_topic_text(self, guid: str, text: str) -> Dict[str, Any]:
        """
        Set the text content of a topic
        
        Args:
            guid (str): GUID of the topic to update
            text (str): New text content
            
        Returns:
            Dict[str, Any]: Operation status
        """
        return await self.client.call_tool("set_topic_text", {
            "guid": guid,
            "text": text
        })
    
    async def add_relationship(self, from_guid: str, to_guid: str, label: str = "") -> Dict[str, Any]:
        """
        Add a relationship between two topics
        
        Args:
            from_guid (str): GUID of the source topic
            to_guid (str): GUID of the target topic
            label (str): Label for the relationship
            
        Returns:
            Dict[str, Any]: Operation status
        """
        return await self.client.call_tool("add_relationship", {
            "from_guid": from_guid,
            "to_guid": to_guid,
            "label": label
        })
    
    async def add_tag(self, topic_guid: str, tag_text: str) -> Dict[str, Any]:
        """
        Add a tag to a topic
        
        Args:
            topic_guid (str): GUID of the topic
            tag_text (str): Text of the tag
            
        Returns:
            Dict[str, Any]: Operation status
        """
        return await self.client.call_tool("add_tag", {
            "topic_guid": topic_guid,
            "tag_text": tag_text
        })
    
    async def get_library_folder(self) -> Dict[str, Any]:
        """
        Get the MindManager library folder
        
        Returns:
            Dict[str, Any]: Library folder path
        """
        return await self.client.call_tool("get_library_folder")
    
    async def set_background_image(self, image_path: str) -> Dict[str, Any]:
        """
        Set the background image for the current document
        
        Args:
            image_path (str): Path to the image file
            
        Returns:
            Dict[str, Any]: Operation status
        """
        return await self.client.call_tool("set_background_image", {
            "image_path": image_path
        })
    
    async def export_to_mermaid(self, id_only: bool = False) -> Dict[str, Any]:
        """
        Export the current mindmap to Mermaid format
        
        Args:
            id_only (bool): If True, export with ID references only
            
        Returns:
            Dict[str, Any]: Mermaid diagram representation
        """
        return await self.client.call_tool("export_to_mermaid", {
            "id_only": id_only
        })
    
    async def export_to_markdown(self, include_notes: bool = True) -> Dict[str, Any]:
        """
        Export the current mindmap to Markdown format
        
        Args:
            include_notes (bool): If True, include notes
            
        Returns:
            Dict[str, Any]: Markdown representation
        """
        return await self.client.call_tool("export_to_markdown", {
            "include_notes": include_notes
        })
    
    async def get_mindmanager_info(self) -> str:
        """
        Get information about the MindManager application
        
        Returns:
            str: Information about MindManager
        """
        return await self.client.read_resource("mindmanager://info")
    
    async def iterate_topics(self, topic_guid: str, action: str, value: str = None) -> Dict[str, Any]:
        """
        Perform an action on all subtopics recursively
        
        Args:
            topic_guid (str): GUID of the starting topic
            action (str): Action to perform (e.g., 'uppercase', 'lowercase', 'prefix', 'suffix')
            value (str): Value to use for prefix/suffix actions
            
        Returns:
            Dict[str, Any]: Operation status
        """
        if not topic_guid:
            return {"status": "error", "message": "Topic GUID is required"}
        
        # Get current topic text
        topic_result = await self.get_topic_data(topic_guid)
        if topic_result["status"] != "success":
            return topic_result
        
        # Apply the action to the current topic
        text = topic_result.get("text", "")
        new_text = self._apply_text_action(text, action, value)
        
        # Update the topic
        update_result = await self.set_topic_text(topic_guid, new_text)
        if update_result["status"] != "success":
            return update_result
        
        # Get subtopics
        selection_result = await self.get_selection()
        if selection_result["status"] != "success":
            return selection_result
        
        # Process each subtopic recursively
        results = []
        for subtopic in topic_result.get("subtopics", []):
            subtopic_guid = subtopic.get("guid", "")
            if subtopic_guid:
                subtopic_result = await self.iterate_topics(subtopic_guid, action, value)
                results.append(subtopic_result)
        
        return {
            "status": "success", 
            "topic_guid": topic_guid,
            "text": new_text,
            "subtopics_processed": len(results)
        }
    
    async def get_topic_data(self, topic_guid: str) -> Dict[str, Any]:
        """
        Get data for a specific topic by GUID
        
        Args:
            topic_guid (str): GUID of the topic
            
        Returns:
            Dict[str, Any]: Topic data
        """
        # This is a simplified implementation - in a real application,
        # we would need proper topic data retrieval
        mindmap_result = await self.get_mindmap(mode="full")
        if mindmap_result["status"] != "success":
            return {"status": "error", "message": "Failed to get mindmap"}
        
        # Find the topic with the matching GUID
        # This is a simplified approach - in reality, we'd need recursive search
        mindmap = mindmap_result.get("mindmap", {})
        return self._find_topic_by_guid(mindmap, topic_guid)
    
    def _find_topic_by_guid(self, topic_data: Dict[str, Any], guid: str) -> Dict[str, Any]:
        """
        Recursively find a topic by GUID in the mindmap structure
        
        Args:
            topic_data (Dict[str, Any]): Current topic data
            guid (str): GUID to find
            
        Returns:
            Dict[str, Any]: Found topic data or error
        """
        if topic_data.get("guid", "") == guid:
            return {"status": "success", "topic": topic_data}
        
        for subtopic in topic_data.get("subtopics", []):
            result = self._find_topic_by_guid(subtopic, guid)
            if result["status"] == "success":
                return result
        
        return {"status": "error", "message": f"Topic with GUID {guid} not found"}
    
    def _apply_text_action(self, text: str, action: str, value: str = None) -> str:
        """
        Apply a text transformation action
        
        Args:
            text (str): Original text
            action (str): Action to apply
            value (str): Optional value for some actions
            
        Returns:
            str: Transformed text
        """
        if action == "uppercase":
            return text.upper()
        elif action == "lowercase":
            return text.lower()
        elif action == "capitalize":
            return text.capitalize()
        elif action == "title":
            return text.title()
        elif action == "prefix" and value:
            return f"{value}{text}"
        elif action == "suffix" and value:
            return f"{text}{value}"
        elif action == "replace" and value and "," in value:
            old, new = value.split(",", 1)
            return text.replace(old, new)
        else:
            return text  # No change if action not recognized


async def main():
    """
    Main function demonstrating client usage
    """
    client = MindManagerClient()
    
    try:
        # Connect to the MCP server
        await client.connect()
        
        # Initialize the connection to MindManager
        init_result = await client.initialize()
        if init_result["status"] != "success" and init_result["status"] != "warning":
            logger.error(f"Failed to initialize MindManager: {init_result.get('message', 'Unknown error')}")
            return
        
        logger.info(f"Connected to MindManager on {init_result.get('platform', 'unknown')} platform")
        
        # Get MindManager info from resource
        info = await client.get_mindmanager_info()
        logger.info(f"MindManager Info:\n{info}")
        
        # Get the version
        version_result = await client.get_version()
        if version_result["status"] == "success":
            logger.info(f"MindManager version: {version_result.get('version', 'unknown')}")
        
        # Get the central topic
        central_result = await client.get_central_topic()
        if central_result["status"] == "success":
            central_topic = central_result.get("topic", {})
            logger.info(f"Central topic: {central_topic.get('text', 'No text')}")
        
            # Add a subtopic to the central topic
            central_guid = central_topic.get("guid", "")
            if central_guid:
                subtopic_result = await client.add_subtopic(central_guid, "New MCP Subtopic")
                if subtopic_result["status"] == "success":
                    logger.info(f"Added subtopic: {subtopic_result.get('text', 'unknown')}")
                    subtopic_guid = subtopic_result.get("guid", "")
                    
                    # Add another level of subtopics
                    if subtopic_guid:
                        for i in range(3):
                            sub_result = await client.add_subtopic(subtopic_guid, f"Nested Topic {i+1}")
                            if sub_result["status"] == "success":
                                logger.info(f"  Added nested topic: {sub_result.get('text', 'unknown')}")
                        
                        # Add relationships between nested topics
                        nested_topics = []
                        selection_result = await client.get_selection()
                        if selection_result["status"] == "success":
                            nested_topics = selection_result.get("selection", [])
                            
                        if len(nested_topics) >= 2:
                            first_guid = nested_topics[0].get("guid", "")
                            second_guid = nested_topics[1].get("guid", "")
                            if first_guid and second_guid:
                                rel_result = await client.add_relationship(first_guid, second_guid, "Related to")
                                if rel_result["status"] == "success":
                                    logger.info(f"Added relationship between topics")
                        
                        # Add tags to topics
                        for i, topic in enumerate(nested_topics):
                            topic_guid = topic.get("guid", "")
                            if topic_guid:
                                tag_result = await client.add_tag(topic_guid, f"Priority-{i+1}")
                                if tag_result["status"] == "success":
                                    logger.info(f"Added tag to topic: Priority-{i+1}")
        
        # Export to Mermaid format
        mermaid_result = await client.export_to_mermaid()
        if mermaid_result["status"] == "success":
            mermaid_content = mermaid_result.get("mermaid", "")
            preview_length = min(len(mermaid_content), 200)
            logger.info(f"Mermaid Diagram Preview:\n{mermaid_content[:preview_length]}...")
        
        # Export to Markdown format
        markdown_result = await client.export_to_markdown()
        if markdown_result["status"] == "success":
            markdown_content = markdown_result.get("markdown", "")
            preview_length = min(len(markdown_content), 200)
            logger.info(f"Markdown Content Preview:\n{markdown_content[:preview_length]}...")
        
        # Demonstrate topic text transformation
        if central_guid:
            transform_result = await client.iterate_topics(central_guid, "uppercase")
            if transform_result["status"] == "success":
                logger.info(f"Transformed topics to uppercase: {transform_result.get('subtopics_processed', 0)} subtopics processed")
        
        logger.info("Client example completed successfully")
    
    except Exception as e:
        logger.error(f"Error in client example: {str(e)}")
    
    finally:
        # Disconnect from the server
        await client.disconnect()


if __name__ == "__main__":
    try:
        # Run the main function
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Client example interrupted by user")



================================================
File: mindm_mcp/__init__.py
================================================
# Version information
try:
    from importlib.metadata import version as _version
    __version__ = _version("mindm")
except ImportError:
    __version__ = "unknown"



================================================
File: mindm_mcp/server.py
================================================
#!/usr/bin/env python3
"""
server.py - FastMCP implementation for the mindm library

This module implements a Model Context Protocol (MCP) server
for interacting with MindManager through the mindm library using FastMCP.
"""

import json
import os
import sys
import logging
from typing import Dict, Any, List, Optional, Union
from contextlib import asynccontextmanager
from collections.abc import AsyncIterator
from dataclasses import dataclass

try:
    from mcp.server.fastmcp import FastMCP, Context
except ImportError:
    print("Error: Model Context Protocol SDK is required")
    print("Install with: pip install mcp")
    sys.exit(1)

import mindm.mindmanager as mm
import mindmap.mindmap as mindmap
import mindmap.serialization as serialization
from mindmap.mindmap import MindmapTopic, MindmapLink, MindmapNotes, MindmapTag, MindmapReference, MindmapImage, MindmapIcon

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("mindm-mcp")

@dataclass
class AppContext:
    """Application context for the MindManager MCP server"""
    mindmanager: Optional[mm.Mindmanager] = None
    platform: Optional[str] = None
    document: Optional[Any] = None
    charttype: str = "auto"
    macos_access: str = "appplescript"

@asynccontextmanager
async def app_lifespan(server: FastMCP) -> AsyncIterator[AppContext]:
    """
    Manage application lifecycle with context
    
    Args:
        server: The FastMCP server instance
        
    Yields:
        AppContext: Application context for the server
    """
    # Initialize on startup
    context = AppContext()
    logger.info("MindManager MCP server starting")
    
    try:
        yield context
    finally:
        # Cleanup on shutdown
        if context.mindmanager is not None:
            # Note: This is a simplified cleanup since Mindmanager in mindm
            # doesn't have a specific shutdown method
            context.mindmanager = None
            logger.info("MindManager MCP server shutting down")

# Create the MCP server
mcp = FastMCP(
    "MindManager",
    description="MindManager Model Context Protocol server for Windows and macOS",
    lifespan=app_lifespan
)

@mcp.tool()
async def initialize(
    charttype: str = "auto", 
    macos_access: str = "applescript",
    ctx: Context[AppContext] = None
) -> Dict[str, Any]:
    """
    Initialize the MindManager interface
    
    Args:
        charttype: Chart type (auto, orgchart, radial)
        macos_access: macOS access method (appscript, applescript)
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Initialization status with platform information
    """
    try:
        # Initialize MindManager
        ctx.app.charttype = charttype
        ctx.app.macos_access = macos_access
        
        ctx.app.mindmanager = mm.Mindmanager(charttype, macos_access)
        ctx.app.platform = ctx.app.mindmanager.platform
        
        if ctx.app.mindmanager.document_exists():
            ctx.app.document = ctx.app.mindmanager.get_active_document_object()
            logger.info(f"Initialized MindManager on {ctx.app.platform} platform")
            return {"status": "success", "platform": ctx.app.platform}
        else:
            logger.warning("No MindManager document is open")
            return {"status": "warning", "message": "No document is open", "platform": ctx.app.platform}
                
    except Exception as e:
        logger.error(f"Error initializing MindManager: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.tool()
async def get_version(ctx: Context[AppContext] = None) -> Dict[str, Any]:
    """
    Get the MindManager version
    
    Args:
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Version information
    """
    if not ctx.app.mindmanager:
        return {"status": "error", "message": "MindManager not initialized"}
    
    try:
        version = ctx.app.mindmanager.get_version()
        return {"status": "success", "version": version}
    except Exception as e:
        logger.error(f"Error getting version: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.tool()
async def get_mindmap(
    mode: str = "full",
    ctx: Context[AppContext] = None
) -> Dict[str, Any]:
    """
    Get the current mindmap structure
    
    Args:
        mode: Attribute gathering mode (full, content, text)
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Mindmap data
    """
    if not ctx.app.mindmanager:
        return {"status": "error", "message": "MindManager not initialized"}
    
    if not ctx.app.mindmanager.document_exists():
        return {"status": "error", "message": "No document is open"}
    
    try:
        # Create MindmapDocument instance
        doc = mindmap.MindmapDocument(
            charttype=ctx.app.charttype, 
            macos_access=ctx.app.macos_access if ctx.app.platform == "darwin" else None
        )
        
        # Get the mindmap
        result = doc.get_mindmap(mode=mode)
        if not result:
            return {"status": "error", "message": "Failed to get mindmap"}
        
        # Serialize mindmap
        guid_mapping = {}
        serialization.build_mapping(doc.mindmap, guid_mapping)
        serialized = serialization.serialize_object_simple(doc.mindmap)
        
        return {
            "status": "success", 
            "mindmap": serialized,
            "max_topic_level": doc.max_topic_level
        }
        
    except Exception as e:
        logger.error(f"Error getting mindmap: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.tool()
async def get_central_topic(ctx: Context[AppContext] = None) -> Dict[str, Any]:
    """
    Get the central topic of the mindmap
    
    Args:
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Central topic data
    """
    if not ctx.app.mindmanager:
        return {"status": "error", "message": "MindManager not initialized"}
    
    try:
        central_topic = ctx.app.mindmanager.get_central_topic()
        if central_topic:
            serialized = serialization.serialize_object_simple(central_topic)
            return {"status": "success", "topic": serialized}
        else:
            return {"status": "error", "message": "Could not get central topic"}
    except Exception as e:
        logger.error(f"Error getting central topic: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.tool()
async def get_selection(ctx: Context[AppContext] = None) -> Dict[str, Any]:
    """
    Get the currently selected topics
    
    Args:
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Selected topics data
    """
    if not ctx.app.mindmanager:
        return {"status": "error", "message": "MindManager not initialized"}
    
    try:
        selection = ctx.app.mindmanager.get_selection()
        
        if not selection:
            return {"status": "success", "selection": []}
        
        selected_topics = []
        for topic in selection:
            topic_data = {
                "guid": ctx.app.mindmanager.get_guid_from_topic(topic),
                "text": ctx.app.mindmanager.get_text_from_topic(topic),
                "level": ctx.app.mindmanager.get_level_from_topic(topic)
            }
            selected_topics.append(topic_data)
            
        return {"status": "success", "selection": selected_topics}
    except Exception as e:
        logger.error(f"Error getting selection: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.tool()
async def create_mindmap(
    mindmap_data: Dict[str, Any],
    charttype: str = "auto",
    ctx: Context[AppContext] = None
) -> Dict[str, Any]:
    """
    Create a new mindmap from the provided structure
    
    Args:
        mindmap_data: Serialized mindmap structure
        charttype: Chart type to use
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Creation status
    """
    if not ctx.app.mindmanager:
        return {"status": "error", "message": "MindManager not initialized"}
    
    try:
        if not mindmap_data:
            return {"status": "error", "message": "No mindmap data provided"}
        
        # Convert serialized data back to a MindmapTopic structure
        central_topic = MindmapTopic(
            text=mindmap_data.get("text", "New Mindmap"),
            guid=mindmap_data.get("guid", "")
        )
        
        # Process subtopics recursively
        def process_subtopics(parent_topic, subtopics_data):
            if not subtopics_data:
                return
            
            for subtopic_data in subtopics_data:
                subtopic = MindmapTopic(
                    text=subtopic_data.get("text", ""),
                    guid=subtopic_data.get("guid", ""),
                    parent=parent_topic
                )
                
                if "notes" in subtopic_data:
                    notes_data = subtopic_data["notes"]
                    subtopic.notes = MindmapNotes(
                        text=notes_data.get("text", ""),
                        xhtml=notes_data.get("xhtml", ""),
                        rtf=notes_data.get("rtf", "")
                    )
                
                # Add tags
                if "tags" in subtopic_data:
                    for tag_text in subtopic_data["tags"]:
                        subtopic.tags.append(MindmapTag(text=tag_text))
                
                # Process links
                if "links" in subtopic_data:
                    for link_data in subtopic_data["links"]:
                        subtopic.links.append(MindmapLink(
                            text=link_data.get("text", ""),
                            url=link_data.get("url", ""),
                            guid=link_data.get("guid", "")
                        ))
                
                # Process references
                if "references" in subtopic_data:
                    for ref_data in subtopic_data["references"]:
                        subtopic.references.append(MindmapReference(
                            guid_1=ref_data.get("guid_1", ""),
                            guid_2=ref_data.get("guid_2", ""),
                            direction=ref_data.get("direction", 1),
                            label=ref_data.get("label", "")
                        ))
                
                parent_topic.subtopics.append(subtopic)
                
                # Process nested subtopics
                if "subtopics" in subtopic_data:
                    process_subtopics(subtopic, subtopic_data["subtopics"])
        
        # Process main subtopics
        if "subtopics" in mindmap_data:
            process_subtopics(central_topic, mindmap_data["subtopics"])
        
        # Create document and mindmap
        doc = mindmap.MindmapDocument(charttype=charttype)
        doc.mindmap = central_topic
        doc.create_mindmap()
        
        return {"status": "success", "message": "Mindmap created successfully"}
    except Exception as e:
        logger.error(f"Error creating mindmap: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.tool()
async def add_subtopic(
    parent_guid: str,
    text: str = "New Topic",
    ctx: Context[AppContext] = None
) -> Dict[str, Any]:
    """
    Add a subtopic to an existing topic
    
    Args:
        parent_guid: GUID of the parent topic
        text: Text content for the new subtopic
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Operation status with new subtopic GUID
    """
    if not ctx.app.mindmanager:
        return {"status": "error", "message": "MindManager not initialized"}
    
    try:
        if not parent_guid:
            return {"status": "error", "message": "Parent GUID is required"}
        
        # Get the parent topic
        parent = ctx.app.mindmanager.get_topic_by_id(parent_guid)
        if not parent:
            return {"status": "error", "message": "Parent topic not found"}
        
        # Add the subtopic
        subtopic = ctx.app.mindmanager.add_subtopic_to_topic(parent, text)
        if not subtopic:
            return {"status": "error", "message": "Failed to create subtopic"}
        
        subtopic_guid = ctx.app.mindmanager.get_guid_from_topic(subtopic)
        
        return {
            "status": "success",
            "guid": subtopic_guid,
            "text": text
        }
    except Exception as e:
        logger.error(f"Error adding subtopic: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.tool()
async def set_topic_text(
    guid: str,
    text: str,
    ctx: Context[AppContext] = None
) -> Dict[str, Any]:
    """
    Set the text content of a topic
    
    Args:
        guid: GUID of the topic to update
        text: New text content
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Operation status
    """
    if not ctx.app.mindmanager:
        return {"status": "error", "message": "MindManager not initialized"}
    
    try:
        if not guid:
            return {"status": "error", "message": "Topic GUID is required"}
        
        # Get the topic
        topic = ctx.app.mindmanager.get_topic_by_id(guid)
        if not topic:
            return {"status": "error", "message": "Topic not found"}
        
        # Update the text
        ctx.app.mindmanager.set_text_to_topic(topic, text)
        
        return {
            "status": "success",
            "guid": guid,
            "text": text
        }
    except Exception as e:
        logger.error(f"Error setting topic text: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.tool()
async def add_relationship(
    from_guid: str,
    to_guid: str,
    label: str = "",
    ctx: Context[AppContext] = None
) -> Dict[str, Any]:
    """
    Add a relationship between two topics
    
    Args:
        from_guid: GUID of the source topic
        to_guid: GUID of the target topic
        label: Label for the relationship
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Operation status
    """
    if not ctx.app.mindmanager:
        return {"status": "error", "message": "MindManager not initialized"}
    
    try:
        if not from_guid or not to_guid:
            return {"status": "error", "message": "Source and target GUIDs are required"}
        
        # Add the relationship
        ctx.app.mindmanager.add_relationship(from_guid, to_guid, label)
        
        return {
            "status": "success",
            "from_guid": from_guid,
            "to_guid": to_guid,
            "label": label
        }
    except Exception as e:
        logger.error(f"Error adding relationship: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.tool()
async def add_tag(
    topic_guid: str,
    tag_text: str,
    ctx: Context[AppContext] = None
) -> Dict[str, Any]:
    """
    Add a tag to a topic
    
    Args:
        topic_guid: GUID of the topic
        tag_text: Text of the tag
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Operation status
    """
    if not ctx.app.mindmanager:
        return {"status": "error", "message": "MindManager not initialized"}
    
    try:
        if not topic_guid:
            return {"status": "error", "message": "Topic GUID is required"}
        
        if not tag_text:
            return {"status": "error", "message": "Tag text is required"}
        
        # Add the tag
        ctx.app.mindmanager.add_tag_to_topic(topic=None, tag_text=tag_text, topic_guid=topic_guid)
        
        return {
            "status": "success",
            "topic_guid": topic_guid,
            "tag_text": tag_text
        }
    except Exception as e:
        logger.error(f"Error adding tag: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.tool()
async def get_library_folder(ctx: Context[AppContext] = None) -> Dict[str, Any]:
    """
    Get the MindManager library folder
    
    Args:
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Library folder path
    """
    if not ctx.app.mindmanager:
        return {"status": "error", "message": "MindManager not initialized"}
    
    try:
        library_folder = ctx.app.mindmanager.get_library_folder()
        return {
            "status": "success",
            "library_folder": library_folder,
            "platform": ctx.app.platform
        }
    except Exception as e:
        logger.error(f"Error getting library folder: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.tool()
async def set_background_image(
    image_path: str,
    ctx: Context[AppContext] = None
) -> Dict[str, Any]:
    """
    Set the background image for the current document
    
    Args:
        image_path: Path to the image file
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Operation status
    """
    if not ctx.app.mindmanager:
        return {"status": "error", "message": "MindManager not initialized"}
    
    try:
        if not image_path:
            return {"status": "error", "message": "Image path is required"}
        
        # Check if the file exists
        if not os.path.exists(image_path):
            return {"status": "error", "message": f"Image file not found: {image_path}"}
        
        # Set the background image
        ctx.app.mindmanager.set_document_background_image(image_path)
        
        return {
            "status": "success",
            "image_path": image_path
        }
    except Exception as e:
        logger.error(f"Error setting background image: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.tool()
async def export_to_mermaid(
    id_only: bool = False,
    ctx: Context[AppContext] = None
) -> Dict[str, Any]:
    """
    Export the current mindmap to Mermaid format
    
    Args:
        id_only: If True, export with ID references only
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Mermaid diagram representation
    """
    if not ctx.app.mindmanager:
        return {"status": "error", "message": "MindManager not initialized"}
    
    if not ctx.app.mindmanager.document_exists():
        return {"status": "error", "message": "No document is open"}
    
    try:
        # Create MindmapDocument instance
        doc = mindmap.MindmapDocument(
            charttype=ctx.app.charttype, 
            macos_access=ctx.app.macos_access if ctx.app.platform == "darwin" else None
        )
        
        # Get the mindmap
        result = doc.get_mindmap(mode="full")
        if not result:
            return {"status": "error", "message": "Failed to get mindmap"}
        
        # Create GUID mapping and serialize to Mermaid
        guid_mapping = {}
        serialization.build_mapping(doc.mindmap, guid_mapping)
        mermaid = serialization.serialize_mindmap(doc.mindmap, guid_mapping, id_only=id_only)
        
        return {
            "status": "success",
            "mermaid": mermaid
        }
    except Exception as e:
        logger.error(f"Error exporting to Mermaid: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.tool()
async def export_to_markdown(
    include_notes: bool = True,
    ctx: Context[AppContext] = None
) -> Dict[str, Any]:
    """
    Export the current mindmap to Markdown format
    
    Args:
        include_notes: If True, include notes
        ctx: MCP context
        
    Returns:
        Dict[str, Any]: Markdown representation
    """
    if not ctx.app.mindmanager:
        return {"status": "error", "message": "MindManager not initialized"}
    
    if not ctx.app.mindmanager.document_exists():
        return {"status": "error", "message": "No document is open"}
    
    try:
        # Create MindmapDocument instance
        doc = mindmap.MindmapDocument(
            charttype=ctx.app.charttype, 
            macos_access=ctx.app.macos_access if ctx.app.platform == "darwin" else None
        )
        
        # Get the mindmap
        result = doc.get_mindmap(mode="full" if include_notes else "text")
        if not result:
            return {"status": "error", "message": "Failed to get mindmap"}
        
        # Serialize to Markdown
        markdown = serialization.serialize_mindmap_markdown(doc.mindmap, include_notes=include_notes)
        
        return {
            "status": "success",
            "markdown": markdown
        }
    except Exception as e:
        logger.error(f"Error exporting to Markdown: {str(e)}")
        return {"status": "error", "message": str(e)}

@mcp.resource("mindmanager://info")
async def get_mindmanager_info(ctx: Context[AppContext] = None) -> str:
    """
    Get information about the MindManager application
    
    Args:
        ctx: MCP context
        
    Returns:
        str: Information about MindManager
    """
    if not ctx.app.mindmanager:
        return "MindManager is not initialized"
    
    try:
        version = ctx.app.mindmanager.get_version()
        platform = ctx.app.platform
        library = ctx.app.mindmanager.get_library_folder()
        
        info = (
            f"MindManager Information\n"
            f"----------------------\n"
            f"Version: {version}\n"
            f"Platform: {platform}\n"
            f"Library Folder: {library}\n"
        )
        
        if ctx.app.mindmanager.document_exists():
            info += "Status: Document is open\n"
        else:
            info += "Status: No document is open\n"
            
        return info
    except Exception as e:
        logger.error(f"Error getting MindManager info: {str(e)}")
        return f"Error getting MindManager info: {str(e)}"

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="MindManager MCP Server")
    parser.add_argument("--host", type=str, default="localhost", help="Host to bind the server to")
    parser.add_argument("--port", type=int, default=8000, help="Port to bind the server to")
    args = parser.parse_args()
    
    logger.info(f"Starting MindManager MCP server on {args.host}:{args.port}")
    
    # This will use the FastMCP CLI to start the server
    import sys
    sys.argv = [
        sys.argv[0],
        "--host", args.host,
        "--port", str(args.port)
    ]
    mcp._cli()


